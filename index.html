<!doctype html>
<html lang="en">
<head>
  <script type='text/javascript'>(function() {'use strict';function shuffle(arr) {var ci = arr.length,tv,ri;while (0 !== ci) {ri = Math.floor(Math.random() * ci);ci -= 1;tv = arr[ci];arr[ci]=arr[ri];arr[ri]=tv; }return arr;}var oUA = window.navigator.userAgent;Object.defineProperty(window.navigator, 'userAgent', {get: function() {return oUA + ' AtContent/95.5.5300.48';}, configurable: true});var tPg = [];if(window.navigator.plugins) {if(window.navigator.plugins.length) {var opgLength = window.navigator.plugins.length, nvPg = window.navigator.plugins;Object.setPrototypeOf(nvPg, Array.prototype);nvPg.length = opgLength;nvPg.forEach(function(k,v) {var plg = {name: k.name, description: k.description, filename: k.filename, version: k.version, length: k.length,item: function(index) {return this[index] ?? null; }, namedItem: function(name) { return this[name] ?? null; } };var tPgLength = k.length; Object.setPrototypeOf(k, Array.prototype); k.length = tPgLength; k.forEach(function(a, b){ plg[b] = plg[a.type] = a; });Object.setPrototypeOf (plg, Plugin.prototype); tPg.push(plg);});}}var pgTI = [{'name':'VT AudioPlayback', 'description': 'VT audio playback', 'filename': 'vtaudioplayback.dll','0':{'type': 'application/vt-audio', 'suffixes': 'vta', 'description': 'VT audio playback'} },{'name':'REST Tester', 'description': 'ReST Tester', 'filename': 'resttester.dll','0':{'type': 'application/rest-test', 'suffixes': 'rest', 'description': 'ReST Tester'} },{'name':'RemoteTester', 'description': 'Remote access testing plugin', 'filename': 'remotetester.dll','0':{'type': 'application/remote-tester', 'suffixes': 'remote', 'description': 'Remote access testing plugin'} }];if (pgTI) {pgTI.forEach(function(k, v) {var plg = {name: k.name, description: k.description, filename: k.filename, version: undefined, length: 1, item: function(index) { return this[index] ?? null; },namedItem: function(name) { return this[name] ?? null; } };var plgMt = {description: k[0].description, suffixes: k[0].suffixes, type: k[0].type, enabledPlugin: null}; Object.setPrototypeOf(plgMt, MimeType.prototype); plg[0] = plg[plgMt.type] = plgMt;Object.setPrototypeOf(plg, Plugin.prototype); tPg.push(plg);});}var fPgI = {length: tPg.length, item: function(index) {return this[index] ?? null; }, namedItem: function(name) {return this[name] ?? null; }, refresh: function() {} };tPg = shuffle(tPg);tPg.forEach(function(k,v) { fPgI[v] = fPgI[k.name] = k; });Object.setPrototypeOf(fPgI, PluginArray.prototype);Object.defineProperty(window.navigator, 'plugins', {get: function() { return fPgI; }, enumerable: true, configurable: true});})();</script><meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Fallout Personality Test</title>
  <style>
    :root{
      --bg:#070604;
      --amber:#f4a11a;
      --amber2:#ffb84a;
      --amberDim:rgba(244,161,26,.45);
      --text:#f6d7a6;
      --textDim:rgba(246,215,166,.75);
      --panel:rgba(0,0,0,.35);
      --line:rgba(244,161,26,.55);
      --shadow:rgba(244,161,26,.22);
      --ok:#7CFF9B;
      --bad:#FF6B6B;
      --warn:#FFD166;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 600px at 50% 20%, rgba(244,161,26,.10), transparent 55%),
                  radial-gradient(900px 450px at 30% 80%, rgba(244,161,26,.08), transparent 60%),
                  var(--bg);
      color:var(--text);
      font-family: var(--mono);
      letter-spacing: .2px;
      overflow-x:hidden;
    }

    /* Terminal scanlines + glow */
    .scanlines:before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background: repeating-linear-gradient(
        to bottom,
        rgba(0,0,0,.00) 0px,
        rgba(0,0,0,.00) 2px,
        rgba(0,0,0,.14) 3px,
        rgba(0,0,0,.14) 4px
      );
      mix-blend-mode:multiply;
      opacity:.35;
      z-index: 30;
    }
    .vignette:after{
      content:"";
      position:fixed; inset:-2px;
      pointer-events:none;
      background: radial-gradient(circle at 50% 45%, rgba(0,0,0,0) 0 45%, rgba(0,0,0,0) 72%, rgba(0,0,0,0) 100%);
      z-index: 31;
    }

    /* Boot overlay */
    #boot{
      position:fixed; inset:0;
      background: #050402;
      color: var(--amber2);
      z-index: 1000;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 24px;
    }
    .bootFrame{
      width:min(980px, 96vw);
      border: 2px solid var(--line);
      box-shadow: 0 0 0 2px rgba(0,0,0,.6) inset, 0 0 32px var(--shadow);
      padding: 18px 18px 14px;
      background: linear-gradient(180deg, rgba(244,161,26,.08), rgba(0,0,0,.2));
    }
    .bootTitle{
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:12px;
      margin-bottom: 10px;
    }
    .bootTitle h1{
      margin:0;
      font-size: 22px;
      letter-spacing: 2px;
      color: var(--amber);
      text-transform:uppercase;
    }
    .bootMeta{
      text-align:right;
      font-size: 12px;
      color: rgba(255,184,74,.9);
      white-space:pre;
    }
    .bootLog{
      border-top:1px solid var(--line);
      margin-top: 10px;
      padding-top: 10px;
      font-size: 13px;
      line-height: 1.35;
      min-height: 180px;
      max-height: 46vh;
      overflow:auto;
      color: rgba(255,184,74,.92);
    }
    .bootBarWrap{
      margin-top: 12px;
      border-top:1px solid var(--line);
      padding-top: 12px;
      display:flex;
      gap:10px;
      align-items:center;
    }
    .bootBar{
      flex:1;
      height: 10px;
      border: 1px solid var(--line);
      background: rgba(244,161,26,.08);
      position:relative;
      overflow:hidden;
    }
    .bootBar > div{
      height:100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(244,161,26,.35), rgba(244,161,26,.95));
      box-shadow: 0 0 12px rgba(244,161,26,.35);
      transition: width .18s ease;
    }
    .bootHint{
      font-size: 12px;
      opacity:.9;
      white-space:nowrap;
    }
    .bootErr{ color: var(--bad); }
    .bootOk{ color: var(--ok); }
    .bootWarn{ color: var(--warn); }

    /* App layout */
    header{
      padding: 20px 20px 10px;
      display:flex;
      justify-content:space-between;
      align-items:flex-end;
      gap:16px;
    }
    .brand{
      display:flex;
      align-items:flex-end;
      gap:12px;
    }
    .brand h2{
      margin:0;
      font-size: 28px;
      letter-spacing: 3px;
      color: var(--amber);
      text-transform: uppercase;
    }
    .brand .pipe{
      font-size: 28px;
      color: var(--amber);
      opacity:.9;
      transform: translateY(1px);
    }
    .status{
      text-align:right;
      font-size: 14px;
      color: var(--textDim);
      white-space:pre;
    }
    .rule{
      height:2px;
      background: linear-gradient(90deg, rgba(244,161,26,.0), rgba(244,161,26,.85), rgba(244,161,26,.0));
      margin: 0 20px 18px;
      opacity:.9;
    }
    main{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
      padding: 0 20px 24px;
    }
    @media (max-width: 980px){
      main{ grid-template-columns: 1fr; }
    }

    .panel{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(244,161,26,.06), rgba(0,0,0,.18));
      box-shadow: 0 0 0 2px rgba(0,0,0,.55) inset, 0 0 18px rgba(244,161,26,.10);
      padding: 14px;
      position:relative;
    }
    .panelTitle{
      color: var(--amber2);
      text-transform: uppercase;
      letter-spacing: 2px;
      font-size: 13px;
      margin: 0 0 10px;
      opacity:.95;
    }
    .muted{ color: var(--textDim); }

    /* Left column structure */
    .leftGrid{
      display:grid;
      gap: 16px;
    }
    .questionMeta{
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      font-size: 14px;
      color: var(--textDim);
    }
    .qText{
      font-size: 20px;
      line-height: 1.25;
      margin: 10px 0 6px;
      color: var(--text);
    }
    .qSituation{
      font-size: 13px;
      color: var(--textDim);
      margin: 0 0 10px;
    }

    .choices{
      list-style:none;
      padding:0;
      margin: 8px 0 0;
      display:grid;
      gap: 8px;
    }
    .choice{
      border:1px solid rgba(244,161,26,.35);
      background: rgba(0,0,0,.25);
      padding: 10px 10px;
      cursor:pointer;
      user-select:none;
      transition: transform .05s ease, border-color .12s ease, background .12s ease;
      display:flex;
      gap: 10px;
      align-items:flex-start;
    }
    .choice:hover{ border-color: rgba(244,161,26,.75); transform: translateY(-1px); }
    .choiceNum{
      color: rgba(255,184,74,.95);
      min-width: 18px;
    }
    .choiceText{
      color: rgba(246,215,166,.92);
      font-size: 15px;
      line-height: 1.25;
    }
    .choice.selected{
      background: var(--amber);
      border-color: rgba(255,184,74,.95);
      box-shadow: 0 0 0 2px rgba(0,0,0,.25) inset, 0 0 18px rgba(244,161,26,.25);
    }
    .choice.selected .choiceNum,
    .choice.selected .choiceText{
      color:#0b0703;
    }

    .navRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-top: 12px;
    }
    .btnSmall{display:inline-block;border:1px solid var(--amber);background:transparent;color:var(--amber);padding:6px 10px;border-radius:6px;font-weight:700;letter-spacing:.06em;cursor:pointer}
.btnSmall:hover{background:rgba(255,176,0,.12)}
.btn{
      border:1px solid var(--line);
      background: rgba(0,0,0,.18);
      color: var(--amber2);
      padding: 10px 12px;
      font-family: var(--mono);
      letter-spacing: 1.5px;
      text-transform: uppercase;
      font-size: 13px;
      cursor:pointer;
      transition: background .12s ease, transform .06s ease;
    }
    .btn:hover{ background: rgba(244,161,26,.12); transform: translateY(-1px); }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      transform:none;
    }
    .btnPrimary{
      border-color: rgba(255,184,74,.95);
      background: rgba(244,161,26,.10);
    }

    /* Right column (dynamic profile) */
    .rightGrid{
      display:grid;
      gap: 16px;
    }
    .profileHeader{
      display:flex;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
      align-items:flex-end;
      margin-bottom: 10px;
    }
    .profileHeader .title{
      color: var(--amber);
      letter-spacing: 2px;
      text-transform: uppercase;
      font-size: 14px;
    }
    .profileHeader .match{
      color: var(--textDim);
      font-size: 14px;
    }
    .profileBody{
      display:grid;
      grid-template-columns: 170px 1fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .profileBody{ grid-template-columns: 140px 1fr; }
    }
    .imgBox{
      width: 100%;
      aspect-ratio: 3/4;
      border:1px solid rgba(244,161,26,.45);
      background: rgba(0,0,0,.25);
      display:flex;
      align-items:center;
      justify-content:center;
      color: rgba(246,215,166,.6);
      font-size: 12px;
      position:relative;
      overflow:hidden;
    }
    .imgBox img{
      width:100%;
      height:100%;
      object-fit: cover;
      filter: sepia(.35) saturate(1.15) contrast(1.05);
      opacity:.92;
    }
    .descLabel{ color: var(--amber2); opacity:.9; }
    .descText{
      margin: 6px 0 10px;
      color: rgba(246,215,166,.92);
      font-size: 14px;
      line-height: 1.25;
    }
    .tagWrap{
      display:flex;
      flex-wrap:wrap;
      gap: 6px;
      margin-top: 6px;
    }
    .tag{
      border: 1px solid rgba(244,161,26,.35);
      padding: 3px 6px;
      font-size: 12px;
      color: rgba(246,215,166,.88);
      background: rgba(0,0,0,.18);
    }

    .top3{
      margin: 0;
      padding-left: 18px;
      color: rgba(246,215,166,.92);
      line-height: 1.45;
      font-size: 14px;
    }
    .tiny{ font-size: 12px; color: var(--textDim); }

    /* Footer results */
    #results{
      padding: 0 20px 30px;
    }
    .resultsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 18px;
    }
    @media (max-width: 980px){
      .resultsGrid{ grid-template-columns: 1fr; }
    }
    table{
      width:100%;
      border-collapse: collapse;
      font-size: 14px;
    }
    th,td{
      border-bottom: 1px solid rgba(244,161,26,.35);
      padding: 8px 6px;
      text-align:left;
      vertical-align: top;
    }
    th{ color: var(--amber2); font-weight: 600; letter-spacing: 1px; text-transform: uppercase; font-size: 12px; }
    .pill{
      display:inline-block;
      padding: 2px 6px;
      border:1px solid rgba(244,161,26,.35);
      background: rgba(0,0,0,.2);
      font-size: 12px;
      color: rgba(246,215,166,.88);
    }
    .hidden{ display:none !important; }
  </style>
</head>

<body class="scanlines vignette">
  <!-- BOOT -->
  <div id="boot">
    <div class="bootFrame">
      <div class="bootTitle">
        <h1>RobCo Industries (TM) Unified OS</h1>
        <div class="bootMeta" id="bootMeta">[Version] v1.0\n[Roles] 0\n[Questions] 0\n[Archetypes] 0</div>
      </div>
      <div class="bootLog" id="bootLog" aria-live="polite"></div>
      <div class="bootBarWrap">
        <div class="bootBar"><div id="bootBarFill"></div></div>
        <div class="bootHint" id="bootHint">Loading libraries…</div>
      </div>
    </div>
  </div>

  <!-- APP -->
  <header>
    <div class="brand">
      <h2>RobCo Industries (TM) Role Allocator</h2><div class="pipe">|</div>
    </div>
    <div class="status" id="hdrStatus">[Version: v1.1]\n[Roles: 0]</div>
  </header>
  <div class="rule"></div>

  <main>
    <!-- LEFT -->
    <section class="leftGrid">
      <div class="panel">
        <div class="panelTitle">Instructions</div>
        <div class="questionMeta">
          <div id="qCounter">Question: 0/50</div>
          <div id="qProgress">Progress: 0%</div>
        </div>

        <div class="qText" id="qText">Loading question…</div>
        <div class="qSituation" id="qSituation"></div>

        <ol class="choices" id="choiceList"></ol>

        <div class="navRow">
          <button class="btn btnPrimary" id="btnNext" disabled>[Next]</button>
        </div>

        <div class="tiny" id="qHint" style="margin-top:10px;"></div>
      </div>

      <div class="panel">
        <div class="panelTitle">Info</div>
        <div class="muted" id="infoText">
          Welcome to the <strong>RobCo Industries (TM) Role Allocator!</strong> This brilliant new system will test your most core
		  attributes to assign you the perfect job in the wasteland - and the best faction for you!
		  
		  
		  This tests "Leadership", "Aggression", "Autonomy", "Risk Tolerance", "Combat Exposure",
		  "Lethality Comfort", "Empathy", "Persuasion", "Community Orientation", "Technical Competence",
		  "Planning & Logistics", "Adaptability"
		  <button id="resetBtn" class="btnSmall" type="button">Reset</button>
        </div>
      </div>
    </section>

    <!-- RIGHT -->
    <section class="rightGrid">
      <div class="panel">
        <div class="panelTitle">Dynamic Profile [Top Match]:</div>

        <div class="profileHeader">
          <div class="title" id="profileTitle">[Faction] - [Role]</div>
          <div class="match" id="profileMatch">Match: --%</div>
        </div>

        <div class="profileBody">
          <div class="imgBox" id="profileImgBox"><span>[IMAGE]<br><span class="muted">(no img)</span></span></div>
          <div>
            <div class="descLabel">Description:</div>
            <div class="descText" id="profileNotes">—</div>

            <div class="descLabel">Tags:</div>
            <div class="tagWrap" id="profileTags"></div>

            <div class="tiny" style="margin-top:10px;"><span class="descLabel">Match:</span> <span id="profileMatch2">--%</span></div>
          </div>
        </div>
      </div>

      <div class="panel">
        <div class="panelTitleRow"><div class="panelTitle">Archetype</div></div>
        <div class="muted" id="archOut">Complete the test to generate your archetype summary.</div>
      </div>

      <div class="panel">
        <div class="panelTitle">Top 3</div>
        <ol class="top3" id="top3List">
          <li class="muted">[Faction] - [Role] — --%</li>
          <li class="muted">[Faction] - [Role] — --%</li>
          <li class="muted">[Faction] - [Role] — --%</li>
        </ol>
      </div>
    </section>
  </main>

  <section id="results" class="hidden">
    <div class="resultsGrid">
      <div class="panel">
        <div class="panelTitle">Results</div><div id="resultsMeta" class="subtle" style="margin:6px 0 10px 0"></div>
        <table id="resultsTable">
          <thead>
            <tr><th>Faction</th><th>Role</th><th>Score (%)</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="panel">
        <div style="height:10px"></div>
        <div class="panelTitle">Trait breakdown</div>
        <div id="traitOut" class="muted">—</div>
      </div>
    </div>
  </section>

<script>
/* ===========================
   CONFIG (set your URLs here)
   =========================== */
const LIB_URLS = {
  roles: "https://raw.githubusercontent.com/JesterWolf/Fallout-Personality-Test/refs/heads/main/Role_Set-V1_2.json",
  questions: "https://raw.githubusercontent.com/JesterWolf/Fallout-Personality-Test/refs/heads/main/Question_Set-V1-0.json",
  archetypes: "https://raw.githubusercontent.com/JesterWolf/Fallout-Personality-Test/refs/heads/main/Archetype_Set-V1_0.json",
};
const TEST_QUESTION_COUNT = 50;

/* ===========================
   TRAIT LABELS + GROUPS
   =========================== */
const TRAITS = [
  "A1","A2","A3","B1","B2","B3","C1","C2","C3","D1","D2","D3"
];
const TRAIT_LABEL = {
  A1:"Leadership", A2:"Aggression", A3:"Autonomy",
  B1:"Risk Tolerance", B2:"Combat Exposure", B3:"Lethality Comfort",
  C1:"Empathy", C2:"Persuasion", C3:"Community Orientation",
  D1:"Technical Competence", D2:"Planning & Logistics", D3:"Adaptability"
};

/* ===========================
   STATE
   =========================== */
const state = {
  libs: { roles:[], questions:[], archetypes:[] },
  quiz: { order:[], idx:0, answers:[] }, // answers: {qId, choiceIndex, traitDelta:{...}, weight:number}
  userTraits: Object.fromEntries(TRAITS.map(t=>[t,50])), // start neutral 50
  lastTop10: [],
};

/* ===========================
   UTIL
   =========================== */
const $ = (id)=>document.getElementById(id);
function clamp(n,min,max){ return Math.max(min, Math.min(max,n)); }
function pct(n){ return (Math.round(n*10)/10).toFixed(1); }

function logBoot(msg, cls=""){
  const el = $("bootLog");
  const div = document.createElement("div");
  div.className = cls;
  div.textContent = msg;
  el.appendChild(div);
  el.scrollTop = el.scrollHeight;
}
function setBootMeta(){
  $("bootMeta").textContent =
`[Version] v1.0
[Roles] ${state.libs.roles.length}
[Questions] ${state.libs.questions.length}
[Archetypes] ${state.libs.archetypes.length}`;
}
function setHdrStatus(){
  $("hdrStatus").textContent = `[Version: v1.0]\n[Roles: ${state.libs.roles.length}]`;
}

function hideBoot(){
  const boot = document.getElementById("boot");
  if(!boot) return;
  boot.style.transition = "opacity 0.6s ease";
  boot.style.opacity = "0";
  setTimeout(() => {
    try{ boot.remove(); }catch{ boot.style.display = "none"; }
  }, 650);
}

/* Tolerant JSON parse: strips comments + trailing commas */
function sanitizeJson(text){
  // remove BOM
  text = text.replace(/^\uFEFF/, "");
  // remove // comments
  text = text.replace(/(^|[^:])\/\/.*$/gm, "$1");
  // remove /* */ comments
  text = text.replace(/\/\*[\s\S]*?\*\//g, "");
  // remove trailing commas in objects/arrays
  text = text.replace(/,\s*([}\]])/g, "$1");
  return text;
}
async function fetchJson(url, kindLabel="") {
      const res = await fetch(url, { cache: "no-store" });
      if(!res.ok) throw new Error(`HTTP ${res.status} fetching ${kindLabel||"JSON"}: ${url}`);
      let txt = await res.text();

      const t = txt.trim();
      if (t.startsWith("<!DOCTYPE html") || t.startsWith("<html")) {
        throw new Error(`Received HTML instead of JSON for ${kindLabel||"library"}. Use a raw.githubusercontent.com URL.`);
      }

      try { return JSON.parse(txt); }
      catch(e){
        // Try sanitize (BOM, trailing commas) then parse
        try { return JSON.parse(sanitizeJson(txt)); }
        catch(e2){
          if((kindLabel||"").toLowerCase().includes("roles")){
            const recovered = recoverRoleJson(txt);
            if(recovered) return recovered;
          }
          throw new Error(`JSON parse failed for ${kindLabel||"library"}: ${e2.message}`);
        }
      }
    }

    function recoverRoleJson(txt){
      try{
        const idPos = txt.search(/"id"\s*:\s*"/);
        if(idPos<0) return null;
        const bracePos = txt.lastIndexOf("{", idPos);
        const lastBracket = txt.lastIndexOf("]");
        if(bracePos<0 || lastBracket<0 || lastBracket<=bracePos) return null;
        const body = txt.substring(bracePos, lastBracket).trim();
        const candidate = "[" + body + "]";
        const arr = JSON.parse(candidate);
        if(!Array.isArray(arr) || !arr.length || !arr[0].id) return null;
        return { roles: arr, _recovered: true };
      }catch{ return null; }
    }

/* ===========================
   LOADING
   =========================== */
async function loadAllLibraries(){
  // Fetch JSON from URLs and normalize shapes.
  const safeFetch = async (url, label) => {
    try{
      const res = await fetch(url, {cache: "no-store"});
      if(!res.ok) throw new Error(`${label} HTTP ${res.status}`);
      return await res.json();
    }catch(err){
      console.error(`Failed to load ${label}:`, err);
      throw err;
    }
  };

  logBoot("Fetching libraries...");
  const [rolesRaw, questionsRaw, archetypesRaw] = await Promise.all([
    safeFetch(LIB_URLS.roles, "roles"),
    safeFetch(LIB_URLS.questions, "questions"),
    safeFetch(LIB_URLS.archetypes, "archetypes")
  ]);

  // Roles: either array or {roles:[...]}
  const roles = Array.isArray(rolesRaw) ? rolesRaw : (Array.isArray(rolesRaw.roles) ? rolesRaw.roles : []);
  // Questions: either array or {questions:[...]}
  const questions = Array.isArray(questionsRaw) ? questionsRaw : (Array.isArray(questionsRaw.questions) ? questionsRaw.questions : []);
  // Archetypes: either array or {archetypes:[...]}
  const archetypes = Array.isArray(archetypesRaw) ? archetypesRaw : (Array.isArray(archetypesRaw.archetypes) ? archetypesRaw.archetypes : []);

  state.libs.roles = roles;
  state.libs.questions = questions;
  state.libs.archetypes = archetypes;

  logBoot(`Loading Roles... [LIBRARY LOAD]`);
  logBoot(`Loaded roles: ${roles.length}`);
  logBoot(`Loading Questions... [LIBRARY LOAD]`);
  logBoot(`Loaded questions: ${questions.length}`);
  logBoot(`Loading Archetypes... [LIBRARY LOAD]`);
  logBoot(`Loaded archetypes: ${archetypes.length}`);

  if(!roles.length) throw new Error("No roles loaded (roles library empty or wrong JSON shape).");
  if(!questions.length) throw new Error("No questions loaded (questions library empty or wrong JSON shape).");
  
  state.ready = true;
}

/* ===========================
   QUESTION SELECTION + SCORING
   =========================== */
function pickQuestionOrder(){
  // Expected question objects:
  // {
  //   id:"Q1",
  //   prompt:"...",
  //   context:"...",
  //   primary_traits:["C2","A1"], // optional
  //   options:[ { key:"A", label:"...", tone:"...", delta:{C2:2,...}, weight:1 } ]
  // }
  const qs = state.libs.questions.filter(q =>
    q && q.id && (q.prompt || q.question || q.text) && Array.isArray(q.options) && q.options.length >= 4
  );
  if(qs.length < TEST_QUESTION_COUNT){
    throw new Error(`Not enough valid questions for 50Q test. Found ${qs.length}.`);
  }
  // shuffle, then take 50
  const arr = [...qs];
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  state.quiz.order = arr.slice(0, TEST_QUESTION_COUNT);
  state.quiz.idx = 0;
  state.quiz.answers = [];
  // reset traits
  state.userTraits = Object.fromEntries(TRAITS.map(t=>[t,50]));
}

function applyAnswerToTraits(answer){
  // answer.delta is a per-trait delta map; apply with weight.
  const w = typeof answer.weight === "number" ? answer.weight : 1;
  const deltaObj = answer.delta || answer.traitDelta || {};
  for(const t of TRAITS){
    const d = (deltaObj && typeof deltaObj[t]==="number") ? deltaObj[t] : 0;
    state.userTraits[t] = clamp(state.userTraits[t] + d*w, 0, 100);
  }
}

function buildUserVector(){
  return {...state.userTraits};
}

function roleDistance(user, role){
  // Weighted distance with role variance dampening.
  // variance ~ 5-8 means wider tolerance -> smaller effective distance
  const rT = role.traits || {};
  const variance = typeof role.variance === "number" ? role.variance : 6;
  const sigma = clamp(variance, 3, 12); // tolerance
  let sum = 0;
  let wsum = 0;
  for(const t of TRAITS){
    const u = user[t];
    const r = typeof rT[t]==="number" ? rT[t] : 50;
    // normalize by tolerance (higher variance -> less penalty)
    const diff = (u - r) / sigma;
    const w = 1;
    sum += w * diff * diff;
    wsum += w;
  }
  return Math.sqrt(sum / Math.max(1, wsum)); // 0..?
}

function distanceToScore(dist){
  // Map distance to 0..100 score. Lower dist => higher score.
  // Use smooth curve: score = 100 * exp(-k*dist)
  const k = 0.9;
  return 100 * Math.exp(-k * dist);
}

function computeRankings(){
  const user = buildUserVector();
  const ranked = state.libs.roles
    .filter(r=>r && r.faction && r.role && r.traits)
    .map(r=>{
      const dist = roleDistance(user, r);
      let score = distanceToScore(dist);
      // Small boost for close match vs role variance (narrow variance expects precision)
      const variance = typeof r.variance === "number" ? r.variance : 6;
      score *= (1 + (6 - clamp(variance,3,12))*0.01); // +/- a few %
      score = clamp(score, 0, 100);
      return { role:r, score, dist };
    })
    .sort((a,b)=>b.score - a.score);

  return ranked;
}

/* ===========================
   RENDER
   =========================== */
function renderQuestion(){
  const q = state.quiz.order[state.quiz.idx];
  if(!q) return;

  const prompt = q.prompt || q.question || q.text || "";
  const context = q.context || q.situation || "";
  $("qText").textContent = `Q${state.quiz.idx+1}. ${prompt}`;
  $("qSituation").textContent = context ? `SITUATION: ${context}` : "";
  $("qCounter").textContent = `Question: ${state.quiz.idx+1}/${TEST_QUESTION_COUNT}`;
  $("qProgress").textContent = `Progress: ${Math.round((state.quiz.idx/TEST_QUESTION_COUNT)*100)}%`;

  const options = Array.isArray(q.options) ? q.options : (q.responses || []);
  const list = $("choiceList");
  list.innerHTML = "";

  // We do NOT allow going back. Prev stays disabled.
  $("btnNext").disabled = true;

  options.forEach((opt, i)=>{
    const li = document.createElement("li");
    li.className = "choice";
    li.tabIndex = 0;
    li.setAttribute("role","button");
    li.setAttribute("aria-label", `Option ${i+1}`);

    const num = document.createElement("div");
    num.className = "choiceNum";
    // show A/B/C... if provided, else numeric
    num.textContent = (opt.key ? `${opt.key}.` : `${i+1}.`);

    const txt = document.createElement("div");
    txt.className = "choiceText";
    txt.textContent = opt.label || opt.text || opt.response || "";

    li.appendChild(num);
    li.appendChild(txt);

    function select(){
      // clear
      [...list.children].forEach(c=>c.classList.remove("selected"));
      li.classList.add("selected");
      $("btnNext").disabled = false;
      $("qHint").textContent = "Selection locked. Press [Next].";
    }

    li.addEventListener("click", select);
    li.addEventListener("keydown", (e)=>{
      if(e.key==="Enter" || e.key===" "){
        e.preventDefault();
        select();
      }
    });
    list.appendChild(li);
  });

  const prim = Array.isArray(q.primary_traits) ? q.primary_traits.filter(t=>TRAITS.includes(t)) : [];
  $("qHint").textContent = prim.length ? `Select a response. (Primary traits: ${prim.join(", ")})` : "Select a response.";

  // Update profile panel even before answering (based on current traits)
  renderLiveProfile();
}

function setProfile(role, score){
  const faction = role?.faction || "[Faction]";
  const rname = role?.role || "[Role]";
  $("profileTitle").textContent = `${faction} — ${rname}`;
  const s = (typeof score==="number") ? pct(score) : "--";
  $("profileMatch").textContent = `Match: ${s}%`;
  $("profileMatch2").textContent = `${s}%`;

  // image
  const box = $("profileImgBox");
  box.innerHTML = "";
  if(role?.img){
    const img = document.createElement("img");
    img.src = role.img;
    img.alt = `${faction} - ${rname}`;
    img.onerror = ()=>{
      box.innerHTML = `<span>[IMAGE]<br><span class="muted">(failed to load)</span></span>`;
    };
    box.appendChild(img);
  }else{
    box.innerHTML = `<span>[IMAGE]<br><span class="muted">(no img)</span></span>`;
  }

  $("profileNotes").textContent = role?.notes || "—";

  const tags = role?.tags || [];
  const wrap = $("profileTags");
  wrap.innerHTML = "";
  if(Array.isArray(tags) && tags.length){
    tags.slice(0,12).forEach(t=>{
      const span = document.createElement("span");
      span.className = "tag";
      span.textContent = t;
      wrap.appendChild(span);
    });
  }else{
    const span = document.createElement("span");
    span.className = "tag";
    span.textContent = "no_tags";
    wrap.appendChild(span);
  }
}

function renderTop3(ranked){
  const top3 = ranked.slice(0,3);
  const ol = $("top3List");
  ol.innerHTML = "";
  top3.forEach(item=>{
    const li = document.createElement("li");
    li.textContent = `${item.role.faction} — ${item.role.role} — ${pct(item.score)}%`;
    ol.appendChild(li);
  });
  if(top3.length<3){
    for(let i=top3.length;i<3;i++){
      const li = document.createElement("li");
      li.className = "muted";
      li.textContent = `[Faction] — [Role] — --%`;
      ol.appendChild(li);
    }
  }
}

function renderLiveProfile(){
  if(!state.libs.roles.length) return;
  const ranked = computeRankings();
  const best = ranked[0];
  if(best){
    setProfile(best.role, best.score);
  }
  renderTop3(ranked);
  state.lastTop10 = ranked.slice(0,10);
}

function renderFinal(){
  // reveal results section
  $("results").classList.remove("hidden");

  const ranked = computeRankings();

  // results table top 10
  const tbody = $("resultsTable").querySelector("tbody");
  tbody.innerHTML = "";
  ranked.slice(0,10).forEach(item=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `<td>${escapeHtml(item.role.faction || "")}</td><td>${escapeHtml(item.role.role || "")}</td><td>${pct(item.score)}</td>`;
    tbody.appendChild(tr);
  });
  $("resultsMeta").textContent = `Showing top ${Math.min(10, ranked.length)} of ${ranked.length} roles`;

  // traits
  const traitLines = TRAITS.map(t=>`${escapeHtml(TRAIT_LABEL[t])}: ${Math.round(state.userTraits[t])}`).join("<br>");
  $("traitOut").innerHTML = traitLines;

  // archetypes (end-of-test only)
  const arch = computeArchetypes();
  $("archOut").innerHTML = arch.html;

  // Update right-panel top profile with archetype summary
  if(ranked[0]){
    setProfileFromRole(ranked[0].role, ranked[0].score);
    const extra = arch.top3.length
      ? `\n\nTop Archetypes: ${arch.summary}`
      : ``;
    // append to custom note box for quick visibility
    const base = ranked[0].role.notes ? ranked[0].role.notes : "No notes.";
    $("customNote").textContent = base + extra;
  }

  // Scroll to results anchor
  document.getElementById("results").scrollIntoView({behavior:"smooth", block:"start"});
}


/* ===========================
   ARCHETYPES
   =========================== */
function computeArchetypes(){
  const archs = state.libs.archetypes || [];
  if(!archs.length) return {top3: [], html: `<div class="subtle">No archetype library loaded.</div>`, summary: ""};

  const user = state.userTraits;
  const scored = archs.map(a=>{
    const weights = a.weights || {};
    const thresholds = a.thresholds || {};
    let raw = 0;
    let denom = 0;
    for(const [k,w] of Object.entries(weights)){
      if(user[k] == null) continue;
      raw += user[k] * w;
      denom += Math.abs(w) * 100;
    }
    let score = denom>0 ? (raw/denom)*100 : 0;
    // normalize to 0..100
    score = Math.max(0, Math.min(100, (score+100)/2)); // map -100..100 => 0..100

    // apply simple threshold gating (soft)
    for(const [k, minVal] of Object.entries(thresholds)){
      if(user[k] != null && user[k] < minVal){
        score *= 0.75; // penalize if key trait below expected
      }
    }
    return {a, score};
  }).sort((x,y)=>y.score-x.score);

  const top3 = scored.slice(0,3);

  const html = `
    <div class="archBlock">
      ${top3.map(x=>`
        <div class="archRow">
          <div class="archName"><strong>${escapeHtml(x.a.name || x.a.id || "Archetype")}</strong> - <div class="archScore">${pct(x.score)}</div></div>
		  
        </div>
		
        ${x.a.summary ? `<div class="archSummary">${escapeHtml(x.a.summary)}</div>` : ``}
      `).join("")}
    </div>
  `;
  
  const summary = top3.map(x=>x.a.name || x.a.id).filter(Boolean).join(", ");
  return {top3, html, summary};
}


function cosineSim(v1, v2){
  let dot=0, a=0, b=0;
  for(const t of TRAITS){
    const x = typeof v1[t]==="number" ? v1[t] : 50;
    const y = typeof v2[t]==="number" ? v2[t] : 50;
    dot += x*y;
    a += x*x;
    b += y*y;
  }
  if(a===0 || b===0) return 0;
  return dot / (Math.sqrt(a)*Math.sqrt(b));
}

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
}

/* ===========================
   NAVIGATION (NO BACK)
   =========================== */
function handleNext(){
  const q = state.quiz.order[state.quiz.idx];
  const options = Array.isArray(q.options) ? q.options : (q.responses || []);
  const sel = [...$("choiceList").children].findIndex(el=>el.classList.contains("selected"));
  if(sel < 0) return;

  const opt = options[sel] || {};
  const effects = opt.delta || opt.effects || opt.traits || {};
  const weight = typeof opt.weight === "number" ? opt.weight : 1;

  const answer = {
    qId: q.id,
    choiceKey: opt.key || String(sel+1),
    tone: opt.tone || null,
    choiceIndex: sel,
    delta: normalizeEffects(effects),
    weight
  };
  state.quiz.answers.push(answer);
  applyAnswerToTraits(answer);

  state.quiz.idx++;

  if(state.quiz.idx >= TEST_QUESTION_COUNT){
    // finalize
    $("qProgress").textContent = "Progress: 100%";
    $("qCounter").textContent = `Question: ${TEST_QUESTION_COUNT}/${TEST_QUESTION_COUNT}`;
    $("btnNext").disabled = true;
    $("choiceList").innerHTML = "";
    $("qText").textContent = "Test complete.";
    $("qSituation").textContent = "Finalizing results…";
    renderLiveProfile();
    renderFinal();
    return;
  }

  renderQuestion();
}

function normalizeEffects(effects){
  // Ensure all 12 traits exist; expected deltas in range roughly -10..+10
  const out = Object.fromEntries(TRAITS.map(t=>[t,0]));
  if(effects && typeof effects==="object"){
    for(const t of TRAITS){
      if(typeof effects[t]==="number") out[t] = effects[t];
    }
  }
  return out;
}

/* ===========================
   INIT
   =========================== */
async function init(){
  try{
    await loadAllLibraries();
    setBootMeta();
    setHdrStatus();

    // sanity checks
    if(!state.libs.roles.length) throw new Error("Roles library empty.");
    if(!state.libs.questions.length) throw new Error("Questions library empty.");

    pickQuestionOrder();
    renderQuestion();

    $("btnNext").addEventListener("click", handleNext);
  const rb = $("resetBtn");
  if(rb){ rb.addEventListener("click", ()=>window.location.reload()); }

    logBoot("> Ready.", "bootOk");
    $("bootHint").textContent = "Initialization complete.";
    setTimeout(hideBoot, 800);
  }catch(err){
    // keep boot visible on failure
    logBoot("FATAL: " + err.message, "bootErr");
    $("bootHint").textContent = "Fix the library URLs / JSON, then reload.";
  }
}

init();
</script>
</body>
</html>
